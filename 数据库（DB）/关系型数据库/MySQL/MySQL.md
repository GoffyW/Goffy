#### 看得见的行和列，看不见的索引，看错的分组（MySQL感想）

#### 行是物理存在的，而分组是逻辑存在的。

一行数据和一列数据都能被人们感知，一行数据会携带一个主键；而一列数据，不仅有列名，还有列的类型。

看的见的东西很重要，但是看不见的东西也同样重要，甚至看错的东西更重要。这个人生哲理放在数据库里面，同样成立

在一次测试种，10000 条记录的数据表中，查找一次平均需要 5000 次比较，而在使用了索引的表中只需要 14 次。

10000 对 14 的对比

#### 索引看不见，摸不着，但是它可以极大的提升查找的速度，当然，世间万物，有好便有坏。

1. 索引占用一定的磁盘空间，就像新华字典有目录便要比没有目录的厚一点
2. 索引大大减缓了插入和删数据的效率，因为每次插入都需要更新索引，一个表拥有的索引越多，进行写操作时平均性能就急剧下降

数据分组用来将数据分为多个逻辑组，从而可以对每个组进行聚合运算，使用方式为：GROUP BY分组字段。分组语句必须和聚合函数一起使用，GROUP BY子句负责将数据分成逻辑组，而聚函数则对每一个组进行统计计算。

虽然GROUP BY子句常常和聚合函数起使用，不过GROUP BY子句并不是不能离开聚合函数而单独使用的

#### 数据分组有以下三大特点

1. ##### 分组与聚合函数

   要分组的所有列都必须位于 GROUP BY子句的列名列表中，也就是没有出现在GROUP BY子句中的列(聚合函数除外)是不能放到SELECET语句后的列名列表中的。比如下面的SQL语句是错误的：

   ```mysql
   SELECT age, salary FROM t_employee GROUP BY age;
   ```

   道理非常简单，采用分组以后的查询结果集是以分组形式提供的，由于每组中人员的工资都不样，所以就不存在能够统代表本组工资水平的salary字段了，所以上面的SQL语句是错误的。不过每组中员工的平均工资却能够统一代表本组工水平，所以可以对Salary使用聚合函数，下面的SQL语句则是正确的：

   ```
   SELECT age, AVG(salary) FROM t_Employee GROUP BY age;
   ```

2. ##### 多级数据分组

   GROUP BY子句中可以指定多个列，只需要将多个列的列名用逗号隔开即。指定多个分组规则以后，数据库系统将按照定义的分组顺序来对数据进行逐分组。首先按照第一个分组列进行分组，然后在每个小组内按照第一个分组列行再次分组...逐层分组，从而实现“组中组”的效果，而查询的结果集是以末一级分组来进行输出的。比如下面的SQL语句将会列出所有分公司的所有门的情况：

   ```mysql
   SELECT subcompany, department FROM t_employee GROUP BY subcompany, department;
   ```

3. ##### 数据分组特点三：数据分组过滤使用HAVING语句

   有的时候需要对部分分组进行过滤，比如只检索人数大于1的年龄段，有的开发人员会使用下面的SQL语句：

   ```mysql
   SELECT age,count(*) FROM t_employee GROUP BY age where count(*) > 1 ;
   ```

   在数据库系统中执行上面的SQL语句时，数据库系统会提示语法错误。这是因为聚合函数不能在WHERE语句中使用，必须使用HAVING子句来代替，比如:

   ```mysql
   SELECT age,count(*) FROM t_employee GROUP BY age having count(*) > 1 ;
   ```

   